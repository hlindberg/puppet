require 'puppet/application'
require 'puppet/configurer'
require 'puppet/util/profiler/aggregate'
require 'puppet/parser/script_compiler'
require 'puppet/fix'

class Puppet::Application::Fix < Puppet::Application

  option("--debug","-d")

  option("--issue ISSUE", "-i") do |arg|
    options[:issue] = the_issue = Puppet::Fix::FixController.parse_issue(arg)
    unless the_issue.mnemonic && the_issue.section
      raise "Given issue must reference a benchmark and contain the section"
    end
  end

  option("--plan NAME", "-p") do |arg|
    options[:plan_name] = arg
  end

  option("--file FILE", "-f") do |arg|
    options[:issues_file] = arg
  end

  option("--logdest LOGDEST", "-l") do |arg|
    handle_logdest_arg(arg)
  end

  option("--explain")

  option("--fixdir DIR") do |arg|
    options[:fixdir] = arg
  end

  def summary
    _("Produces remediation fixes for issues found when scanning for benchmark compliance or vulnerabilities")
  end

  def help
    <<-HELP

puppet-fix(8) -- #{summary}
========

SYNOPSIS
--------
  Produces remediation fixes for issues found when scanning for benchmark compliance or vulnerabilities.


USAGE
-----
puppet fix [-h|--help] [-V|--version] [-d|--debug][--explain]
  [-i|--issue] [-if|--issues_file] [--fixdir DIR]
  [-p|--plan]
  [-l|--logdest syslog|eventlog|<FILE>|console]
  <file>


DESCRIPTION
-----------
Puppet fix can produce remediation fixes for known found (or explicitly given) issues, such as
benchmark "controls", or "vulnerabilities".

# TBD: When provided with a modulepath, via command line or config file, Puppet
# Fix can load remediation fixes, functions, types, tasks and plans from modules.

Currently it offers output of instructions how to run an available fix given the id
of an issue (i.e. benchmark, vulnerability, issue).

Issues are mapped to fixes via hiera. Each module should bind its provided fixes
to a key '<mymodule>::fix::fixmap', where '<mymodule>' is the name of the module.
The bound value shoud be a hash with issue-id key and fix-id value.

The key 'fix::include_modules' should be bound to an array of module names from which fixes
should be included - it is looked up with unique merge.
This allows the configuration to differ depending on operating system.

An environment level 'fix::fixmap' is looked up and is deeply merge with higher priority
than any of the fixmaps found in modules. This allows the configuration to use fixes
from modules not containing fixmaps.

Benchmark Mnemonic
------------------
A fully qualified benchmark control is something like this:

xccdf_org.cisecurity.benchmarks_benchmark_2.2.0.1_CIS_Red_Hat_Enterprise_Linux_7_Benchmark/1.1.1.1_Ensure_mounting_of_cramfs_filesystem_is_disabled

Which is a horribly long thing to work with. Puppet fix therefore uses a short form mnemonic/moniker for these long identities.
Those are defined in a `fixconf.yaml` file that is read by Puppet Fix.

TODO: Later it will be possible to define benchmarks in modules.

---
benchmarks:
  - 
    benchmark:
      id: "xccdf_org.cisecurity.benchmarks_benchmark_2.2.0.1_CIS_Red_Hat_Enterprise_Linux_7_Benchmark"  version: "2.2.0.1"
      name: "cis-rhel7"
      family: "cis"
    facts: {
      os:
        name: "RedHat"
        family: "RedHat"
        release:
          full: "7.2.1511"
          major: "7"
          minor: "2"

  - benchmark:
      id: "xccdf_org.cisecurity.benchmarks_benchmark_2.2.0.1_CIS_Red_Hat_Enterprise_Linux_8_Benchmark"
      name: "cis-rhel8"
      # rest as for rhel7


This identifies benchmarks as 'cis-rhel7', 'cis-rhel8', etc. and also provides the variable values for switching
data sets and mappings in hiera.

OPTIONS
-------
* --explain
  Outputs hiera explain output to stderr for all hiera lookups done by Puppet Fix. This is intended for debugging
  where information is coming from.

* --issue, -i
  The single issue for which some action is wanted. It is given on the form <mnemonic>::<section><name>.
  Mutually exclusive with --issues_file.

* --issues_file, -if
  A yaml file with none/one or more issues for which some action is wanted.
  Mutually exclusive with --issue.

* --fixdir DIR
  Tells puppet fix to use the given DIR as the directory where the environment to use is located.
  Defaults to current directory.

* --version:
  The version of the benchmark for which the given --benchmark is a reference into.

* --plan
  The name of the plan. Defaults to `generated_plan`

Note that any setting that's valid in the configuration
file is also a valid long argument. For example, 'environment' is a
valid setting, so you can specify '--environment mytest'
as an argument.

See the configuration file documentation at
https://puppet.com/docs/puppet/latest/configuration.html for the
full list of acceptable parameters. A commented list of all
configuration options can also be generated by running puppet with
'--genconfig'.

* --debug:
  Enable full debugging.

* --help:
  Print this help message

* --logdest:
  Where to send log messages. Choose between 'syslog' (the POSIX syslog
  service), 'eventlog' (the Windows Event Log), 'console', or the path to a log
  file. Defaults to 'console'.

  A path ending with '.json' will receive structured output in JSON format. The
  log file will not have an ending ']' automatically written to it due to the
  appending nature of logging. It must be appended manually to make the content
  valid JSON.

  A path ending with '.jsonl' will receive structured output in JSON Lines
  format.

EXAMPLES
--------
    $ puppet fix -i cis-rhel7:/1.1.1.1_Ensure_mounting_of_cramfs_filesysten_is_disabled
    $ puppet fix -i cis-rhel7:/1.1.1.1

AUTHOR
------
Henrik Lindberg


COPYRIGHT
---------
Copyright (c) 2019 Puppet Inc., LLC Licensed under the Apache 2.0 License (<--TODO: Probably not)

HELP
  end

  def main
    require 'byebug'; debugger
    # The tasks feature is always on
    Puppet[:tasks] = true

    controller = Puppet::Fix::FixController.new

    # only pass options the controller understands
    controller_options = options.select {|k,_| [
        :issue,
        :plan_name,
        :explain,
        :fixdir
      ].include?(k) }
    controller_options[:issue_files] = command_line.args

    controller.run(**controller_options)

    exit(0)

    rescue => detail
      Puppet.log_exception(detail)
      exit(1)
  end

  def setup
    # TODO: Should read and print its own configuration (in addition to puppet's)
    # exit(Puppet.settings.print_configs ? 0 : 1) if Puppet.settings.print_configs?

    handle_logdest_arg(Puppet[:logdest])
    Puppet::Util::Log.newdestination(:console) unless options[:setdest]

    Signal.trap(:INT) do
      $stderr.puts _("Exiting")
      exit(1)
    end

    # When running a script, the catalog is not relevant, and neither is caching of it
    Puppet::Resource::Catalog.indirection.cache_class = nil

    set_log_level

    # Configure profiling... TODO: This may not be of value
    if Puppet[:profile]
      @profiler = Puppet::Util::Profiler.add_profiler(Puppet::Util::Profiler::Aggregate.new(Puppet.method(:info), "fix"))
    end
  end

end

require 'puppet/application'
require 'puppet/configurer'
require 'puppet/util/profiler/aggregate'
require 'puppet/parser/script_compiler'

class Puppet::Application::Fix < Puppet::Application

  require 'puppet/application/fix/fix_model'

  option("--debug","-d")

  option("--issue ISSUE", "-i") do |arg|
    options[:issue] = arg
  end

  option("--file FILE", "-f") do |arg|
    options[:issues_file] = arg
  end

  option("--test","-t")
  option("--verbose","-v")

  option("--logdest LOGDEST", "-l") do |arg|
    handle_logdest_arg(arg)
  end

  def summary
    _("Produces remediation fixes for issues found when scanning for vulnerabilities")
  end

  def help
    <<-HELP

puppet-fix(8) -- #{summary}
========

SYNOPSIS
--------
  Produces remediation fixes for issues found when scanning for vulnerabilities.


USAGE
-----
puppet script [-h|--help] [-V|--version] [-d|--debug]
  [-i|--issue] [-f|--issue_file]
  [-v|--version]
  [-l|--logdest syslog|eventlog|<FILE>|console] [--noop]
  <file>


DESCRIPTION
-----------
Puppet fix can produce remediation fixes for known found (or explicitly given) issues, such as vulnerabilities.
When provided with a modulepath, via command line or config file, Puppet
Fix can load remediation fixes, functions, types, tasks and plans from modules.

Currently it offers output of instructions how to run an available fix given the id
of an issue (i.e. benchmark, vulnerability, issue).

Issues are mapped to fixes via hiera. Each module should bind its provided fixes
to a key '<mymodule>::fix::fixmap', where '<mymodule>' is the name of the module.
The bound value shoud be a hash with issue-id key and fix-id value.

The key 'fix::include_modules' should be bound to an array of module names from which fixes
should be included - it is looked up with unique merge.
This allows the configuration to differ depending on operating system.

An environment level 'fix::fixmap' is looked up and is deeply merge with higher priority
than any of the fixmaps found in modules. This allows the configuration to use fixes
from modules not containing fixmaps.

Benchmark ID
------------
The fully qualified benchmark ID is something like:

xccdf_org.cisecurity.benchmarks_benchmark_2.2.0.1_CIS_Red_Hat_Enterprise_Linux_7_Benchmark/1.1.1.1_Ensure_mounting_of_cramfs_filesystem_is_disabled

Which is a horribly long thing to work with on the command line, and to use to switch between data sets in hiera.
When feeding a result from a scan, these identifiers are obtained from the result file. For command line work it is possible to provide short
form names that are read from a configuration file.

Benchmark identifiers also needs to be mapped to canonical values to be used in hiera as standardized by Facter facts.

---
benchmarks:
  - id: "xccdf_org.cisecurity.benchmarks_benchmark_2.2.0.1_CIS_Red_Hat_Enterprise_Linux_7_Benchmark"
    facts: {
      benchmark: {
        version: "2.2.0.1"
        name: "cis_rhel7"
        family: "cis"
      }
      os: {
        name: "RedHat"
        family: "RedHat"
        release: {
          full: "7.2.1511"
          major: "7"
          minor: "2"
        }
      }
    }
  - "xccdf_org.cisecurity.benchmarks_benchmark_2.2.0.1_CIS_Red_Hat_Enterprise_Linux_8_Benchmark"
    benchmark_name: "cis_rhel8"
    # rest as for rhel7

# Configure a default so this does not have to be given
default_benchmark: "rhel7"

This makes it possible to identify benchmarks as 'cis_rhel7', 'cis_rhel8', etc. and also provides the variable values for switching
data sets and mappings in hiera. The setting 'default_benchmark' makes it possible to just give the name of the benchmark check/rule.

OPTIONS
-------
* --issue
  The single issue for which some action is wanted. It is given on the form <mnemonic>::<section><name>. Mutually exclusive with --issues_file.

* --issues_file
  A yaml file with none/one or more issues for which some action is wanted. Mutually exclusive with --issue. (Not yet implemented)

* --version:
  The version of the benchmark for which the given --benchmark is a reference into.

* --benchmark
  The identity of the benchmark for which a fix is wanted

Note that any setting that's valid in the configuration
file is also a valid long argument. For example, 'environment' is a
valid setting, so you can specify '--environment mytest'
as an argument.

See the configuration file documentation at
https://puppet.com/docs/puppet/latest/configuration.html for the
full list of acceptable parameters. A commented list of all
configuration options can also be generated by running puppet with
'--genconfig'.

* --debug:
  Enable full debugging.

* --help:
  Print this help message

* --logdest:
  Where to send log messages. Choose between 'syslog' (the POSIX syslog
  service), 'eventlog' (the Windows Event Log), 'console', or the path to a log
  file. Defaults to 'console'.

  A path ending with '.json' will receive structured output in JSON format. The
  log file will not have an ending ']' automatically written to it due to the
  appending nature of logging. It must be appended manually to make the content
  valid JSON.

  A path ending with '.jsonl' will receive structured output in JSON Lines
  format.

* --noop:
  Use 'noop' mode where Puppet runs in a no-op or dry-run mode. This
  is useful for seeing what changes Puppet will make without actually
  executing the changes. Applies to tasks only.

EXAMPLES
--------
    $ puppet fix -i cis::1.1.1.1_Ensure_mounting_of_cramfs_filesysten_is_disabled
    $ puppet fix -i cis::Ensure_mounting_of_cramfs_filesysten_is_disabled
    $ puppet fix --modulepath=/root/dev/modules -e 'notice("hello world")'


AUTHOR
------
Henrik Lindberg


COPYRIGHT
---------
Copyright (c) 2019 Puppet Inc., LLC Licensed under the Apache 2.0 License

HELP
  end

# Not needed - super version is fine
#  def app_defaults
#    super.merge({
#      :default_file_terminus => :file_server,
#    })
#  end

  attr_reader :fix_config
  attr_reader :known_benchmarks

  def run_command

    # Needed if fix is going to call Bolt directly
    #
#    if Puppet.features.bolt?
#      Puppet.override(:bolt_executor => Bolt::Executor.new) do
#        main
#      end
#    else
#      raise _("Bolt must be installed to use the script application")
#    end

    # For now, just call main
    main
  end

  def main
    # The tasks feature is always on
    Puppet[:tasks] = true

    parsed_issue = options[:parsed_issue] = parse_issue(options[:issue])

    # TODO: if no --issue was given and instead an --issues_file is given, then it should loop over
    # the issues in that file. If both --issue and --issues_file are given at the same time then it should error.
    #
    #
    if options[:issue] && options[:issues_file]
      raise ArgumentError, "--issue and --issues_file cannot be used at the same time"
    end

    if options[:issue]
      # Check that some input was given
      # A mnemonic (if not given, the default value for it from settings)
      # Either a section or a name (both are ok)
      #
      mnemonic = parsed_issue['mnemonic'] || @fix_config['default_benchmark']
      if mnemonic.nil?
        raise ArgumentError, "No benchmark was given and 'default_benchmark' is not set"
      end

      unless parsed_issue['section'] || parsed_issue['name']
        raise ArgumentError, "No reference to an issue was given, needs either a <section> or a <name> to match against"
      end
    elsif options[:issues_file]
      issues = parse_issues_file(options[:issues_file])
    else
      raise ArgumentError, "No issue was given, use --issue or --issues_file"
    end

    puts produce_plan("my::testplan", issues)

    # Stop here for now
    return

    # Set the puppet code or file to use.
    if options[:code] || command_line.args.length == 0
      Puppet[:code] = options[:code] || STDIN.read
    else
      manifest = command_line.args.shift
      raise _("Could not find file %{manifest}") % { manifest: manifest } unless Puppet::FileSystem.exist?(manifest)
      Puppet.warning(_("Only one file can be used per run. Skipping %{files}") % { files: command_line.args.join(', ') }) if command_line.args.size > 0
    end

    unless Puppet[:node_name_fact].empty?
      # Collect the facts specified for that node
      unless facts = Puppet::Node::Facts.indirection.find(Puppet[:node_name_value])
        raise _("Could not find facts for %{node}") % { node: Puppet[:node_name_value] }
      end

      Puppet[:node_name_value] = facts.values[Puppet[:node_name_fact]]
      facts.name = Puppet[:node_name_value]
    end

    # Find the Node
    unless node = Puppet::Node.indirection.find(Puppet[:node_name_value])
      raise _("Could not find node %{node}") % { node: Puppet[:node_name_value] }
    end

    configured_environment = node.environment || Puppet.lookup(:current_environment)

    apply_environment = manifest ?
      configured_environment.override_with(:manifest => manifest) :
      configured_environment

    # Modify the node descriptor to use the special apply_environment.
    # It is based on the actual environment from the node, or the locally
    # configured environment if the node does not specify one.
    # If a manifest file is passed on the command line, it overrides
    # the :manifest setting of the apply_environment.
    node.environment = apply_environment

    # TRANSLATION, the string "For puppet script" is not user facing
    Puppet.override({:current_environment => apply_environment}, "For puppet script") do
      # Merge in the facts.
      node.merge(facts.values) if facts

      # Add server facts so $server_facts[environment] exists when doing a puppet script
      # SCRIPT TODO: May be needed when running scripts under orchestrator. Leave it for now.
      #
      node.add_server_facts({})

      begin
        # Compile the catalog

        # When compiling, the compiler traps and logs certain errors
        # Those that do not lead to an immediate exit are caught by the general
        # rule and gets logged.
        #
        begin
          # support the following features when evaluating puppet code
          # * $facts with facts from host running the script
          # * $settings with 'settings::*' namespace populated, and '$settings::all_local' hash
          # * $trusted as setup when using puppet apply
          # * an environment
          #

          # fixup trusted information
          node.sanitize()

          compiler = Puppet::Parser::ScriptCompiler.new(node.environment, node.name)
          topscope = compiler.topscope

          # When scripting the trusted data are always local, but set them anyway
          topscope.set_trusted(node.trusted_data)

          # Server facts are always about the local node's version etc.
          topscope.set_server_facts(node.server_facts)

          # Set $facts for the node running the script
          facts_hash = node.facts.nil? ? {} : node.facts.values
          topscope.set_facts(facts_hash)

          # create the $settings:: variables
          topscope.merge_settings(node.environment.name, false)

          compiler.compile()

        rescue Puppet::ParseErrorWithIssue, Puppet::Error
          # already logged and handled by the compiler for these two cases
          exit(1)
        end

        exit(0)
      rescue => detail
        Puppet.log_exception(detail)
        exit(1)
      end
    end

  ensure
    if @profiler
      Puppet::Util::Profiler.remove_profiler(@profiler)
      @profiler.shutdown
    end
  end

  def setup
    # Configuration
    # -------------

    # TODO: Read config file
    @fix_config = load_config

    # Set up known_benchmarks (can be loaded from the config) - later to (todo: somehow) be combined
    # with benchmarks delivered in modules.
    #
    @benchmarks = (@fix_config['benchmarks'] || []).map {|b| Model::Benchmark.from_hash(b) }

    build_fixes(@fix_config['fixes'])

    # TODO: Should read and print its own configuration (in addition to puppet's)
    # exit(Puppet.settings.print_configs ? 0 : 1) if Puppet.settings.print_configs?

    handle_logdest_arg(Puppet[:logdest])
    Puppet::Util::Log.newdestination(:console) unless options[:setdest]

    Signal.trap(:INT) do
      $stderr.puts _("Exiting")
      exit(1)
    end

    # When running a script, the catalog is not relevant, and neither is caching of it
    Puppet::Resource::Catalog.indirection.cache_class = nil

    set_log_level

    # Configure profiling... TODO: This may not be of value
    if Puppet[:profile]
      @profiler = Puppet::Util::Profiler.add_profiler(Puppet::Util::Profiler::Aggregate.new(Puppet.method(:info), "fix"))
    end
  end

  def init_known_benchmarks(benchmarks)
  end

  # Loads the fix specific configuration from a file in current directory and returns a hash of
  # settings.
  #
  def load_config
    # TODO: This is obviously very simplistic, and the file should be named something else
    # There should be a way to point to the config as well.
    #
    begin
      return YAML.load_file("fixconf.yaml")
    rescue Errno::ENOENT => e
      # No config file - ignore
      # Return a default config - an empty hash
    end
    {}
  end

  # Parses an issue string consisting of <mnemonic>::<section>[_.]<name>
  # where:
  # * mnemonic is alphanumeric, starting with a letter
  # * section is a sequence of decimal digits separated by '.' or '_'
  # * name is any string until end of string after a separator of '_' or '.'
  #
  # Returns a hash with the corresponding entries as string keys
  #
  def parse_issue(issue_string)
    return {} unless issue_string.is_a?(String)

    regexp = /\A(?:(?<mnemonic>[A-Za-z][A-Za-z0-9_-]*(::[A-Za-z][A-Za-z0-9_-]*)?)::)?(?<section>[0-9](?:[._][0-9])*)?[._]?(?<name>.+)?/
    matches = issue_string.match(regexp)
    captured = matches ? matches.named_captures : { }
    # Normalize the section
    unless captured['section'].nil?
      captured['section'].gsub!(/_/,'.')
    end
    captured
  end

  # Parses the given file_name and validates its "issues on nodes" content
  #
  def parse_issues_file(file_name)
    loaded = YAML.load_file(file_name)
    validate_and_normalize_issues_file(loaded, file_name)
  end

  # Validates issue_file type content coming from a given location (filename) is only for reporting/ reference
  # This also normalizes constructs like node/nodes into nodes.
  #
  def validate_and_normalize_issues_file(data, source_location)
    # Top level is either a hash with keys 'benchmark', 'nodes', and 'issues', or an
    # Array of such hashes
    #
    data = [data] unless data.is_a?(Array)
    unless data.all? {|x| x.is_a?(Hash) }
      raise "--issues_file #{source_location} must be a hash or array of hashes, got a nested array"
    end
    data.each_with_index do | section, i |

      ##--BENCHMARK
      #   Must have a reference to a known benchmark

      unless get_benchmark(section['benchmark'])
        raise "--issues_file #{source_location} at index #{i} does not have a reference to a known benchmark. Got '#{section['benchmark']}'."
      end

      ## -- NODE / NODES
      #     Must have a node, or list of nodes

      node = section['node']
      nodes = section['nodes']
      if node && nodes
        raise "--issues_file #{source_location} at index #{i} uses both 'node' and 'nodes' - both not allowed at the same time."
      end
      if !(node || nodes)
        raise "--issues_file #{source_location} at index #{i} must contain either 'node' or 'nodes'"
      end

      if nodes 
        if !nodes.is_a?(Array)
          raise "--issues_file #{source_location} at index #{i} has a 'nodes' entry that is not an array"
        end
      else
        # Normalize node to be nodes: [node]
        nodes = section['nodes'] = [node]
        section.delete('node')
      end

      # validate the node names
      # TODO: should probably strip them as well
      unless nodes.all? {|n| n.is_a?(String) && n =~ /[a-zA-Z0-9]/ }
        raise "--issues_file #{source_location} at index #{i} The node name '#{node}' is not acceptable as the name of a node"
      end

      ## -- ISSUES
      #     Optionally have an (optionally empty) list of valid issues

      the_issues = section['issues']
      if !the_issues.nil?
        unless the_issues.is_a?(Array) && (the_issues.empty? || the_issues.all? {|x| x.is_a?(Hash) })
          raise "--issues_file #{source_location} at index #{i} The 'issues' must be an array of hashes"
        end

        the_issues.each_with_index do |issue, ii|
          the_issue = parse_issue(issue['issue'])
          unless the_issue['section'] || the_issue['name']
            raise "--issues_file #{source_location} at index #{i}, issue[#{ii}} must contain benchmark 'section', 'name' or both"
          end

          if the_issue['mnemonic']
            raise "--issues_file #{source_location} at index #{i}, issue[#{ii}} cannot reference a benchmark. Got '#{the_issue['mnemonic']}'"
          end
          # Set the parsed and validated value
          issue['issue'] = the_issue
        end

        ## -- TODO: params
      end
    end
  end

  def build_fixes(fixes_array)
    @fixes = {}
    return if fixes_array.nil?
    fixes_array.each do | fix |
      f = Fix.new(fix)
      @fixes[f.section] = f
    end
  end

  def find_fix(issue)
    # Find a corresponding fix, using section as key
    # TODO: possibly, if section is missing, use the name instead

    # For now, the fixes are in settings, later composed differently using hiera
    raise "No fixes found" if @fixes.empty?

    @fixes[issue['section']] || NOFIX
  end

  class Fix
    attr_reader :fix_map

    def initialize(fix_map)
      @fix_map = fix_map
    end

    def section
      @fix_map['section']
    end

    def name
      @fix_map['name']
    end

    def to_pp(target_spec_name)
      the_fix = @fix_map['fix'] || {}
      if the_fix['task']
        task_to_pp(the_fix, target_spec_name)
      elsif  the_fix['command']
        command_to_pp(the_fix, target_spec_name)
      elsif the_fix['plan']
        plan_to_pp(the_fix, target_spec_name)
      else
        "# No fix available"
      end
    end

    def command_to_pp(the_command, target_spec)
      command_string = the_command['command_string']
      parts = [
        "run_command('#{command_string}'",
        "${target_spec}",
      ] << the_command['params'].map do |p, v|
        "'#{p}' => #{v.inspect}" # TODO: v.inspect is a temporary crutch to get quoted strings
      end << ")"
      parts.join(", ")
    end

    def plan_to_pp(the_plan, target_spec)
      plan_name = the_plan['plan']
      parts = [
        "run_plan('#{plan_name}'",
        "nodes => ${target_spec}",
      ] << the_plan['params'].map do |p, v|
        "'#{p}' => #{v.inspect}" # TODO: v.inspect is a temporary crutch 
      end << ")"
      parts.join(", ")
    end

    def task_to_pp(the_task, target_spec)
      task_name = the_task['task']
      parts = [
        "run_task('#{task_name}'",
        "nodes => $#{target_spec}",
      ] << the_task['params'].map do |p, v|
        "'#{p}' => #{v.inspect}" # TODO: v.inspect is a temporary crutch 
      end << ")"
      parts.join(", ")
    end
  end

  NOFIX = Fix.new({})

  # Gets Benchmark object by mnemonic
  #
  def get_benchmark(mnemonic)
    @benchmarks.find(mnemonic) {|b| b.name == mnemonic }
  end

  def produce_plan(plan_name, reported_issues)
    return '' if reported_issues.nil?
    # For each issue
    # Find the fix
    # Output the fix
    the_app = self
    template = ERB.new(<<-EOF)
## Puppet Fix generated remediation plan
## Created on <%= Time.now %>
##
plan <%= plan_name %>() { <%
  reported_issues.each_with_index do | report, index |
    joined_nodes = report['nodes'].map {|n| n.inspect }.join(", ") %>
  # Benchmark: <%= report['benchmark'] %>
  $targets_<%= index %> = [ <%= joined_nodes %> ] <%
  report['issues'].each do | entry |
     result = the_app.find_fix(entry['issue']).to_pp(sprintf("targets_%s", index)) %>
  # Section: <%= entry['issue']['section'] %>
  # name: <%= entry['issue']['name'] %> 
  <%= result %>
<% end end %>
}
EOF
    template.result(binding)
  end
end
